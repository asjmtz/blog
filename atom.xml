<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Asjmtz's Blog]]></title>
  <subtitle><![CDATA[不想做画家的黑客不是好前端o(∩_∩)o]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://iamtutu.com/"/>
  <updated>2015-06-10T10:34:59.000Z</updated>
  <id>http://iamtutu.com/</id>
  
  <author>
    <name><![CDATA[Asjmtz]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Aurelia 文档小翻译]]></title>
    <link href="http://iamtutu.com/2015/06/09/Aurelia-%E6%96%87%E6%A1%A3%E5%B0%8F%E7%BF%BB%E8%AF%91/"/>
    <id>http://iamtutu.com/2015/06/09/Aurelia-文档小翻译/</id>
    <published>2015-06-09T07:52:02.000Z</published>
    <updated>2015-06-10T10:34:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Browser_Support">Browser Support</h2><p>Aurelia 支持现代浏览器，包括 Chrome，Firefox，IE11，Safari 8。但是我们也提供兼容 IE9 及以上的方法。</p>
<p>为了需要兼容 IE9 及以上，我们需要为 MutationObservers 添加一个额外的 polyfill。实现方法，用 <code>jspm</code> 安装 <code>github:polymer/mutationobservers</code>。接着在 <code>aurelia-bootstrapper</code> 的外层这样调用它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jspm_packages/github/polymer/mutationobservers@0.4.2/MutationObserver.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"jspm_packages/system.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"config.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">  <span class="comment">// Loads WeakMap polyfill needed by MutationObservers</span></span><br><span class="line">  System.<span class="keyword">import</span>(<span class="string">'core-js'</span>).then( <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Imports MutationObserver polyfill</span></span><br><span class="line">    System.<span class="keyword">import</span>(<span class="string">'mutationobservers'</span>).then( <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Ensures start of Aurelia when all required IE9 dependencies are loaded</span></span><br><span class="line">      System.<span class="keyword">import</span>(<span class="string">'aurelia-bootstrapper'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: Aurelia 本身不需要 WeakMap，但是上面的 MutationObserver ployfill 会用到。 </p>
</blockquote>
<h2 id="Startup_&amp;_Configuration">Startup &amp; Configuration</h2><p>大多数的平台都为代码执行设置有一个 “main” 或者入口点，Aurelia 也不例外。如果你已经看过了 <a href="http://aurelia.io/get-started.html" target="_blank" rel="external">Get Started</a>，你会发现这个 <code>aurelia-app</code> 属性。把它简单的放到一个 HTML 元素中，Aurelia 的引导器会加载一个 <code>app.js</code> 和 <code>app.html</code>，将他们通过数据绑定在一起，然后将他们注册到 <code>aurelia-app</code> 属性放置的地方。</p>
<p>有时，我们想要配置框架，或者在向用户展示信息之前优先跑些代码，又或者，在项目进行中时，向需要 startup 配置的方向发展。因此，我们可以给 <code>aurelia-app</code> 一个值，这个值指向一个配置模块。该模块 export 一个单独的函数 <code>configure</code>。Aurelia 引用 <code>configure</code> 函数，向他传入 Aurelia 对象，之后我们可以用来 配置框架的这些那些东西 : ) 。</p>
<p>实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;LogManager&#125; <span class="keyword">from</span> <span class="string">'aurelia-framework'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ConsoleAppender&#125; <span class="keyword">from</span> <span class="string">'aurelia-logging-console'</span>;</span><br><span class="line"></span><br><span class="line">LogManager.addAppender(<span class="keyword">new</span> ConsoleAppender());</span><br><span class="line">LogManager.setLevel(LogManager.logLevel.debug);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">configure</span><span class="params">(aurelia)</span> </span>&#123;</span><br><span class="line">  aurelia.use</span><br><span class="line">    .defaultBindingLanguage()</span><br><span class="line">    .defaultResources()</span><br><span class="line">    .router()</span><br><span class="line">    .eventAggregator()</span><br><span class="line">    .plugin(<span class="string">'./path/to/plugin'</span>);</span><br><span class="line"></span><br><span class="line">  aurelia.start().then(a =&gt; a.setRoot(<span class="string">'app'</span>, <span class="built_in">document</span>.body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了自定义插件的代码，以上的代码都是 <code>aurelia-app</code> 默认会帮你完成的工作。如果你使用配置文件的方法，你需要自己配置这些文件，但是你也可以安装自定义的插件，用一些 services 设置依赖注入的 container，安装视图模版中用到的全局资源等。</p>
<p>如果你使用配置文件的方法，你可以只写一个简单的文件，他包含了所有我们上面栗子的标准选项，然后这么写：<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">function</span> configure(aurelia) &#123;</span><br><span class="line">  aurelia.use</span><br><span class="line">    .standardConfiguration<span class="literal">()</span></span><br><span class="line">    .developmentLogging<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">  aurelia.start<span class="literal">()</span>.<span class="keyword">then</span>(a =&gt; a.setRoot<span class="literal">()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Logging">Logging</h3><p>Aurelia 框架有一个简单的 logging abstraction，默认是无操作的。上面的配置展示了如何安装一个附件( appender )来向控制台 console 输出 log 数据。我们还可以设置 log level，<code>logLevel</code> 的值可以为：<code>none</code>, <code>error</code>, <code>warn</code>, <code>info</code> and <code>debug</code>。</p>
<p>你可以简单的创建自己的 <code>appender</code>。配合 appender 接口来实现一个 类。最好的栗子是看源码：<a href="https://github.com/aurelia/logging-console/blob/master/src/index.js" target="_blank" rel="external">console log appender’s source</a></p>
<h3 id="Plugins">Plugins</h3><p><strong>插件</strong> 是只有一个 exported <code>configure</code> 函数的  module 。当启动时，Aurelia 会 load 所有插件模块 ，将 Aurelia 的实例传入插件们的 <code>configure</code> 函数并执行。</p>
<p>插件可从 配置函数 返回一个 <code>Promise</code> 来完成异步的配置任务。在写插件时，要确保明确的提供所有的 metadata，包括给 Custom Elements 使用的 View Strategy。</p>
<p>为了 配置你的插件的来源，在 app 中你可以设置一个函数或者对象作为配置函数的第二个参数，在插件中可以用到，你的插件的使用者可以这么用：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">aurelia</span><span class="class">.use</span><span class="class">.plugin</span>(<span class="string">'./path/to/plugin'</span>, config =&gt; &#123; <span class="comment">/* configuration work */</span> &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note:  插件不能依赖 Aurelia 的命名约定。因为 Aurelia 的命名约定是可配置的，所以第三方插件应该明确，确保在不同的上下文环境下函数的执行。</p>
</blockquote>
<h4 id="Promises">Promises</h4><p>Aurelia 默认使用 ES6 原生的 Promises 或者 polyfill。你也可以使用这个不错的 Promise 库 <a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">Bluebird</a> 来替换。使用它只需要将它放到页面上其他引用的脚本前面，他回使用自己标准的 Promise 实现，这个方法比原生的 Promise 要快，并且拥有更好的 debugging 支持。另外，在使用 Babel 编译器的时候，可以使用 <a href="http://babeljs.io/docs/usage/transformers/other/bluebird-coroutines/" target="_blank" rel="external">coroutines</a> 来改进异步代码的书写。</p>
<h3 id="The_Aurelia_Object">The Aurelia Object</h3><p>因为自定义配置模块和插件都需要用到 Aurelia Object，下面是一个简单的 API 的解释：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export class Aurelia &#123;</span><br><span class="line">  loader<span class="value">:Loader;</span> <span class="comment">//the module loader</span></span><br><span class="line">  container<span class="value">:Container;</span> <span class="comment">//the app-level dependency injection container</span></span><br><span class="line">  use<span class="value">:Plugins;</span> <span class="comment">//the plugins api (see above)</span></span><br><span class="line"></span><br><span class="line">  <span class="function">withInstance</span>(type, instance)<span class="value">:Aurelia;</span> <span class="comment">//DI helper method (pass through to container)</span></span><br><span class="line">  <span class="function">withSingleton</span>(type, implementation)<span class="value">:Aurelia;</span> <span class="comment">//DI helper method (pass through to container)</span></span><br><span class="line">  <span class="function">globalizeResources</span>(..<span class="class">.resourcePaths</span>)<span class="value">:Aurelia;</span> <span class="comment">//module ids of resources relative to the configuration/plugin module</span></span><br><span class="line">  <span class="function">renameGlobalResource</span>(resourcePath, newName); <span class="comment">//renames a globally available resource to avoid naming conflicts</span></span><br><span class="line"></span><br><span class="line">  <span class="function">start</span>()<span class="value">:Promise;</span> <span class="comment">//starts the framework, causing plugins to be installed and resources to be loaded</span></span><br><span class="line">  <span class="function">setRoot</span>(root, applicationHost)<span class="value">:Promise;</span> <span class="comment">//set your "root" or "app" view-model and display it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Views_and_View_Models">Views and View Models</h2><p>在 Aurelia 中，用户交互元素由 View 和 View-model 对来实现。View 由 HTML 完成，会被渲染到 DOM 中，View-model 由 JavaScript 完成， 向 View 提供数据和交互行为。模版引擎和 DI（依赖注入）负责创建配对之间的联系，并且为进程执行一个可预言的生命周期？（不理解）</p>
<p>在连接成功之后， Aurelia 强大的数据绑定就能将 View 和 View-model 的数据和视图联合起来，实现数据双向绑定。</p>
<ul>
<li>这样的分隔方法有利于 开发和设计 的合作: ) </li>
<li>可维护性、灵活的架构、甚至代码控制……</li>
</ul>
<h3 id="Dependency_Injection_(DI)">Dependency Injection (DI)</h3><p>View-model 和其他的交互元素：Custom Elements、Customs Attributes，都被作为 类来创建，然后框架中使用依赖注入容器来实例化。 这种代码容易模块化和测试。</p>
<p>你可以将需求拆分为小的对象，合作来完成一个目标，而不是写一个巨大的类。DI 可以配合完成拼接。</p>
<p>使用 DI时，在你的 类中的 constructor 中传入，下面是栗子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;inject&#125; from <span class="string">'aurelia-framework'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HttpClient&#125; from <span class="string">'aurelia-http-client'</span>;</span><br><span class="line"></span><br><span class="line">@inject(HttpClient)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CustomerDetail&#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(http)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.http = http;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ES7 或者 TypeScript 中可以使用 Decrators，这时你只需要加一个 <code>inject</code> decorator，每注入一个类型传一个参数。如果你使用的语法没有支持 Decrators，或者是不想用，也可以添加一个叫 <code>inject</code> 的静态属性或者方法到你的类中。这样必须返回一个可注入的类型数组（array of injectable types）。下面是一个在 CoffeeScript 结合 CommomJS 模块的栗子：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpClient = require(<span class="string">'aurelia-http-client'</span>).HttpClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Flickr</span><br><span class="line">  <span class="function"><span class="keyword">constructor</span>:</span> (@http) -&gt;</span><br><span class="line">  @inject:[HttpClient]</span><br></pre></td></tr></table></figure>
<p>如果你正在使用　TypeScript 开发，可以用 <code>--emitDecoratorMetadata</code> 编译标识配合 Aurelia 的 <code>autoinject()</code> decorator 来让框架读取标准 TS 类型信息。这样做之后，就不需要去复制类型了。代码实例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;autoinject&#125; from <span class="string">'aurelia-framework'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HttpClient&#125; from <span class="string">'aurelia-http-client'</span>;</span><br><span class="line"></span><br><span class="line">@autoinject()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CustomerDetail&#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(http:HttpClient)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.http = http;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: TypeScript 实现这个编译选项的方式中有个有趣的细节，他适用于任何decorator。所以，如果你在自己的 TS 类中拿到一些其他的 Decorator ，就不需要引入 <code>autoinject</code> decorator，那些 Type information 仍然能被 Aurelia 的依赖注入框架发现。</p>
</blockquote>
<p>当明确的声明依赖时，他们不一定非得是 constructor types，还可以是 resolvers 的实例。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Lazy, inject&#125; from <span class="string">'aurelia-framework'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HttpClient&#125; from <span class="string">'aurelia-http-client'</span>;</span><br><span class="line"></span><br><span class="line">@inject(Lazy.of(HttpClient))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CustomerDetail&#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(getHTTP)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getHTTP = getHTTP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的 <code>Lazy</code> resolver 实际上没有提供一个 <code>HttpClient</code> 的实例，它提供一个可以随时返回 <code>HttpClient</code> 实例的函数。你可以通过写个类继承 Resolver 来创建 resolvers，或者使用我们提供的一些方便的 resolvers：</p>
<ul>
<li><code>lazy</code> -  Injects a function for lazily evaluating the dependency.<ul>
<li>ex . <code>Lazy.of(HttpClient)</code></li>
</ul>
</li>
<li><code>All</code> - Injects an array of all services registered with the provided key<ul>
<li>ex. <code>All.of(Plugin)</code></li>
</ul>
</li>
<li><code>Optional</code> -  Injects an instance of a class only if it already exists in the container; null otherwise.<ul>
<li>ex. <code>Optional.of(LoggedInUser)</code></li>
</ul>
</li>
</ul>
<p>另外关于 resolvers，你也可以用 <code>Registration</code> decorators 来指定一个默认的注册(registration)，或者一个实例的生命周期。默认情况下，DI 容器假设每个实例都是单例？（everything is a singleton instance）one instance for the app。但是你可以用一个registration decorator 来修改，示例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;transient, inject&#125; from <span class="string">'aurelia-framework'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HttpClient&#125; from <span class="string">'aurelia-http-client'</span>;</span><br><span class="line"></span><br><span class="line">@transient()</span><br><span class="line">@inject(HttpClient)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CustomerDetail&#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(http)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.http = http;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所写，每次请求 DI 容器返回 CustomerDetail 的时候会返回一个新的实例，而不是一个 singleton。<code>singleton</code> 和 <code>transient</code> registrations 都提供给外部使用，但是你也可以通过构建一个实现 <code>register(container, key, fn)</code> 函数的类，来创建 registration 。之后，就可以简单了用 <code>registration</code> decorator 来把它的实例添加到你的类中。</p>
<p>如果你不能或不想用 decorators。don’t worry! 我们准备了后备方案。只要提供一个静态的 <code>decorators</code> 属性或方法，然后使用我们 链式的 <code>Decorators</code> helper。 这位 helper 有对应我们所有 decorators 的方法。So，无论你使用何种语言都十分简单使用。下面是 CoffeeScript 的实例：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpClient = require(<span class="string">'aurelia-http-client'</span>).HttpClient;</span><br><span class="line">Decorators = require(<span class="string">'aurelia-framework'</span>).Decorators;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CustomerDetail</span><br><span class="line">  <span class="function"><span class="keyword">constructor</span>:</span> (@http) -&gt;</span><br><span class="line">  @decorators:Decorators.transient().inject(HttpClient);</span><br></pre></td></tr></table></figure>
<h3 id="Parent_View_Models">Parent View Models</h3><p>By default a View-model’s access is limited to injected objects as well as children of the class. Sometimes it may be desirable to refer to objects and methods on a parent View-model, which can be achieved by storing the parent during the bind method of the view lifecycle:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildViewModel</span> </span>&#123;</span><br><span class="line">  bind(bindingContext) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$parent = bindingContext;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tamplating">Tamplating</h2><p>Aurelia 的模版引擎负责加载视图和他们所需要的资源，以及完美编译 HTML 和渲染 UI 到屏幕上。创建一个视图，你仅仅需要一个HTML文件，在里面加上<code>HTMLTemplate</code> 即可，下面是个简单的视图：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">template</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">template</span>&gt;</span><br></pre></td></tr></table></figure>
<p>所有在 <code>template</code> 标签中的内容都由 Aurelia 管理。但是，因为 Aurelia 使用 HTMLImport 技术来加载视图，所以你也可以写入 <code>links</code> ，他们也会被正确的加载，还可以用相对路径的写法哦，具体是指：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="keyword">type</span>=<span class="string">"text/css"</span> href=<span class="string">"./hello.css"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">template</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> class=<span class="string">"hello"</span>&gt;<span class="type">Hello</span> <span class="type">World</span>!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">template</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这样你就可以为每个视图选择需要加载的样式，还可以使用 Web components on the fly。</p>
<p>当你需要引入一个 Aurelia 特制 (Aurelia-specific) 的资源时，比如一个 Aurelia Custom Element，Custom Attribute or Value Converter，你会在视图中用到一个 <code>require</code> 元素。栗子：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">template</span>&gt;</span><br><span class="line">  &lt;require <span class="keyword">from</span>='./nav-bar'&gt;&lt;/require&gt;</span><br><span class="line"></span><br><span class="line">  &lt;nav-bar router.<span class="keyword">bind</span>=<span class="string">"router"</span>&gt;&lt;/nav-bar&gt;</span><br><span class="line"></span><br><span class="line">  &lt;<span class="keyword">div</span> class=<span class="string">"page-host"</span>&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">template</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在这个例子中 <code>nav-bar</code> 是一个我们需要使用的 Aurelia Custom Element。在 我们使用 <code>require</code> element 时，框架的资源管道会处理输入的元件。这么做有以下好处：</p>
<ul>
<li>去重 - 资源只会在 app 中被 download 一次，即使其他的视图需要相同的元素，也只会被下载一次。</li>
<li>一次编译 - 模版中这样引入自定义元素在整个应用周期只会被编译一次</li>
<li>Local Scope( 本地作用域？ ) - 引入的资源只能在引入他的视图中可见，通过这样排除全局作用域的方法，可以有效减少命名冲突的可能性、加强可维护性和易懂性</li>
<li>重命名 - 资源可以被重命名，这样当你在同一视图，引入两个名字相同或相似的第三方资源时，就可以使用这个特性<ul>
<li>ex. <code>&lt;require from=&quot;./nav-bar&quot; as=&quot;foo-bar&quot;&gt;&lt;/require&gt;</code> - 现在你可以使用 <code>foo-bar</code> 元素来替代 <code>nav-bar</code> 元素。（这是基于 ES6 的import 语法，重命名被认为是代替 Alias 的方法，因为他完全的重命名了type ）</li>
</ul>
</li>
<li>包 - require 可以指向一个包括多资源的模块，包中的所有的资源会被导入同个视图</li>
<li>可扩展性 - 我们可以定义新的资源类型，You can define new types of resources which, when required in this way, can execute custom loading (async one-time) and registration (once per-view). This is a declarative, extensible resource loading pipeline.</li>
<li>ES6 - 代码是由 ES6 loader 加载而不是 HTMLImport 机制， enabling all the features and extensibility of your loader。这么设计完全统一了所有app资源的加载方法，无论是 JS 还是 HTML</li>
</ul>
<p>在你的视图中，你会用到上面提到的各种不同的资源以及数据绑定</p>
<blockquote>
<p>Note: 你可能会觉得每个视图中都要引入东西很无聊╮(╯▽╰)╭。Remember ，在引导（ bootstrapping）阶段，你可以配置 Aurelia 可以让所有视图使用的全局资源。Just use <code>aurelia.globalizeResources(...resourcePaths)</code>。</p>
</blockquote>
<p>Aurelia  polyfills browsers 不包括支持 templates。但是，模版的一些特性可以被 polyfilled ，需要 workarounds。特别当 <code>template</code> 元素在 <code>select</code> 和 <code>table</code> 元素中时，下面的代码在不原生支持 templates 的浏览器中不能实现：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;<span class="keyword">template</span> repeat.<span class="keyword">for</span>=<span class="string">"customer of customers"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;$&#123;customer.fullName&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/<span class="keyword">template</span>&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>为了重复输出 <code>tr</code> 元素，可以简单的修改为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">repeat.for</span>=<span class="value">"customer of customers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">td</span>&gt;</span>$&#123;customer.fullName&#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Databinding">Databinding</h3><p>数据绑定让你可以将一个 JS 对象中的状态和行为连接到 HTML 视图中。当连接建立之后，任何的连接的属性改动都会在一个或两个方向上同步。</p>
<p>JS 对象中的改变能反应在视图上，视图上的修改能映射到 JS 对象中。</p>
<p>要建立这样连接，可以在 HTML 中利用 <code>binding commands</code> 。通过使用一个绑定操作符 <code>.</code> 来声明绑定命令。当 HTML 的属性中包含一个 <code>.</code>，编译器会将属性的名字和值传到绑定语言（binding language）来编译，当视图被创建时，通过建立的连接，我们就能使用一个或更多的绑定表达式了。</p>
<p>可以自己扩展绑定命令，但是 Aurelia 提供了一个覆盖大多数常用使用案例的命令集合。</p>
<h4 id="bind,_one-way,_two-way_&amp;_one-time">bind, one-way, two-way &amp; one-time</h4><p>最常用的绑定命令是 <code>.bind</code>。这样会让所有的属性使用单向绑定来绑定，而元素的值使用双向绑定。</p>
<p>这意味着神马呢？</p>
<p><strong>单向绑定</strong>是说改变JS 的 view-models 会反映到 view 上，而反方向不会反应。<br><strong>双向绑定</strong>是指每个方向改变都会影响到对方。</p>
<p><code>.bind</code> 会假设你在绑定表单元素的时候会希望 view 上的 form 改变反应到 view-model 上，而其他的情况下就使用单向绑定，这是因为，在许多的时候，双向绑定到一个非表单元素上是无意义的。下面是 <code>.bind</code> 的小栗子：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">input</span> type=<span class="string">"text"</span> value.bind=<span class="string">"firstName"</span>&gt;</span><br><span class="line">&lt;<span class="tag">a</span> href.bind=<span class="string">"url"</span>&gt;Aurelia&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>input</code> 元素会将他的值绑定到 view-model 的 <code>firstName</code> 属性上。改变 <code>firstName</code> 的属性会更新 <code>input.value</code> ，而改变 <code>input.value</code> 会更新 <code>firstName</code> 的值。另一边，<code>a</code> 标签的 <code>href</code> 属性绑在了 view-model 的 <code>url</code> 属性上。只有改变 <code>url</code> 的值会影响 <code>href</code>，反方向则不通。</p>
<p>我们也可以明确的使用 <code>.one-way</code> 或者 <code>.two-way</code> 来代替 <code>.bind</code>。举一个常见的栗子：当需要引入一个 Web Components 作为输入类型的控件时，你可以这样使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">markdown-editor</span> <span class="attribute">value.two-way</span>=<span class="value">"markdown"</span>&gt;</span><span class="tag">&lt;/<span class="title">markdown-editor</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[在学习 Aurelia，整篇的英文文档很容易分神，顺手翻译一下文档，还有很多不懂的地方啊]]>
    
    </summary>
    
      <category term="Aurelia" scheme="http://iamtutu.com/categories/Aurelia/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[a 标签中的 input 文本不能被选中]]></title>
    <link href="http://iamtutu.com/2015/04/30/a-%E6%A0%87%E7%AD%BE%E4%B8%AD%E7%9A%84-input-%E6%96%87%E6%9C%AC%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%80%89%E4%B8%AD/"/>
    <id>http://iamtutu.com/2015/04/30/a-标签中的-input-文本不能被选中/</id>
    <published>2015-04-30T02:14:14.000Z</published>
    <updated>2015-04-30T02:22:27.000Z</updated>
    <content type="html"><![CDATA[<p>若你写了这样一个 <code>html</code> 结构</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">a</span> href=<span class="string">"http://iamtutu.com"</span>&gt; </span><br><span class="line">	&lt;<span class="tag">input</span> type=<span class="string">"text"</span> value=<span class="string">"something"</span> /&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>会发现 <code>&lt;input&gt;</code> 中的文字不能选中，会触发 <code>&lt;a&gt;</code> 。</p>
<p>尝试把 <code>href = &quot;javascript:void();&quot;</code> 这样，但是还是不能选中。</p>
<p>最后，将 <code>&lt;a&gt;</code> 的attr属性移除<code>$().removeAttr()</code> 就能选中了。</p>
<p>虽然表面看起来就没有必要有 <code>&lt;a&gt;</code> 了，但是如果在需要编辑一个连接的文本时，这个结构还是不错的。编辑的时候，将 <code>href</code> 属性先储存在别的地方，移除 <code>&lt;a&gt;</code> 的 href 属性，编辑完成之后，再恢复就 OK 了。</p>
<p>另外，css 选中文本的样式<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">::selection &#123; background:lightblue;</span> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[a 标签中的 input 文本不能被选中]]>
    
    </summary>
    
      <category term="html" scheme="http://iamtutu.com/categories/html/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git config 常用命令]]></title>
    <link href="http://iamtutu.com/2015/04/30/git-config-%E5%B8%B8%E7%94%A8%E5%91%BD/"/>
    <id>http://iamtutu.com/2015/04/30/git-config-常用命/</id>
    <published>2015-04-30T02:11:17.000Z</published>
    <updated>2015-04-30T02:11:50.000Z</updated>
    <content type="html"><![CDATA[<p>P.S:  做全局的设置时，可以这样 <code>git config --global</code></p>
<h3 id="帮助">帮助</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> config --help <span class="comment"># 打开详细版手册</span></span><br><span class="line">git config -h     <span class="comment"># 简单暴力我喜欢</span></span><br></pre></td></tr></table></figure>
<h3 id="查看">查看</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config -<span class="keyword">l</span> </span><br><span class="line">git config --<span class="keyword">list</span></span><br></pre></td></tr></table></figure>
<h3 id="修改">修改</h3><p>没有特殊情况下，都可以设置为全局配置。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> <span class="keyword">alias</span>.co checkout</span><br></pre></td></tr></table></figure></p>
<h3 id="增加">增加</h3><p>如果事先没有这个配置名称，git 会提示你在前面增加  <code>--add</code> 命令</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">add</span> <span class="comment">core</span><span class="string">.</span><span class="comment">editor</span> <span class="comment">"'C:\xxx\xxx\sublime_text</span><span class="string">.</span><span class="comment">ext'</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">wait"</span></span><br></pre></td></tr></table></figure>
<h3 id="删除">删除</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">unset</span> <span class="comment">alias</span><span class="string">.</span><span class="comment">co</span> <span class="comment">checkout</span></span><br></pre></td></tr></table></figure>
<p>如果提示什么有多个相同的设置。。。的英文时，按照错误指示<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> --unset-<span class="keyword">all</span> alias.<span class="keyword">co</span> checkout</span><br></pre></td></tr></table></figure></p>
<p>不得不说，git 的提示是挺周到的。</p>
<h2 id="git_config_小抄">git config 小抄</h2><p>下面是我现在用的配置</p>
<h3 id="1-_设置别名">1. 设置别名</h3><p>有些常用命令略长，当 tab 键也不能释放我们的愤怒时，可以试试给他们起外号。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> <span class="keyword">alias</span>.co checkout</span><br><span class="line">git config --<span class="keyword">global</span> <span class="keyword">alias</span>.ci commit</span><br><span class="line">git config --<span class="keyword">global</span> <span class="keyword">alias</span>.br branch</span><br><span class="line">git config --<span class="keyword">global</span> <span class="keyword">alias</span>.st status</span><br><span class="line">git config --<span class="keyword">global</span> <span class="keyword">alias</span>.mg <span class="string">'merge --no-ff'</span></span><br></pre></td></tr></table></figure>
<h3 id="2-设置默认浏览器">2.设置默认浏览器</h3><p>在 git commit 的时候，可以使用浏览器来写提交注释，基本告别了挤在一行的悲惨命运</p>
<p>P.S :  Windows 环境，sublime text 3 版本<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">add</span> <span class="comment">core</span><span class="string">.</span><span class="comment">editor</span> <span class="comment">"'C:\xxx\xxx\sublime_text</span><span class="string">.</span><span class="comment">ext'</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">wait"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[git config 常用命令]]>
    
    </summary>
    
      <category term="git" scheme="http://iamtutu.com/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git bash 使用 sublime text 打开文件]]></title>
    <link href="http://iamtutu.com/2015/04/30/git-bash-%E4%BD%BF%E7%94%A8-sublime-text-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6/"/>
    <id>http://iamtutu.com/2015/04/30/git-bash-使用-sublime-text-打开文件/</id>
    <published>2015-04-30T02:09:46.000Z</published>
    <updated>2015-04-30T02:25:51.000Z</updated>
    <content type="html"><![CDATA[<p>用 hexo 写博客时，使用 <code>hexo new postname</code> 新建了一个新的文件，每次想直接打开都要从文件夹打开，实在不符合我们这些 Geek（懒人）的做派。纠结很久之后，终于找到这篇大大的<a href="https://danlimerick.wordpress.com/2014/01/07/git-for-windows-tip-opening-sublime-text-from-bash/" target="_blank" rel="external">博客</a>，他的解决办法如下。</p>
<h3 id="1-_新建一个文件命名为你想要的命令，比如_subl_没有后缀（重要），内容如下：">1. 新建一个文件命名为你想要的命令，比如 <code>subl</code> 没有后缀（重要），内容如下：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span></span><br><span class="line"><span class="string">"C:\Program Files\Sublime Text 2\sublime_text.exe"</span> <span class="variable">$1</span> &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行是说这是个 shell 脚本</li>
<li>第二行的字符串是sublime 的安装目录</li>
<li>第二行的$1 是取的命令之后输入的参数</li>
<li>第二行的&amp;是此命令在后台打开，这样sublime打开之后，就不会阻塞你的git bash</li>
</ul>
<h3 id="2-_保存到_C:\Program_Files_(x86)\Git\bin_目录下">2. 保存到 <code>C:\Program Files (x86)\Git\bin</code> 目录下</h3><h3 id="3-_使用方法">3. 使用方法</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subl <span class="type">text</span>.txt</span><br></pre></td></tr></table></figure>
<p>在当前目录打开一个新文件</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subl .</span><br></pre></td></tr></table></figure>
<p>是不是 so easy ！shell 脚本麻吉强大，此时墙裂后悔上课时(～﹃～)~zZ啊。</p>
]]></content>
    <summary type="html">
    <![CDATA[git bash 使用 sublime text 打开文件]]>
    
    </summary>
    
      <category term="git" scheme="http://iamtutu.com/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSON 是否为空]]></title>
    <link href="http://iamtutu.com/2015/04/30/JSON-%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"/>
    <id>http://iamtutu.com/2015/04/30/JSON-是否为空/</id>
    <published>2015-04-30T02:08:28.000Z</published>
    <updated>2015-04-30T02:09:17.000Z</updated>
    <content type="html"><![CDATA[<p>jquery 中的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.isEmptyObject = <span class="function"><span class="keyword">function</span> <span class="params">( obj )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> name;</span><br><span class="line">		<span class="keyword">for</span> ( name <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[js 判断 JSON对象是否为空的写法]]>
    
    </summary>
    
      <category term="js" scheme="http://iamtutu.com/categories/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git bash 之 export 与 ~/.bashrc]]></title>
    <link href="http://iamtutu.com/2015/04/30/git-bash-%E4%B9%8B-export-%E4%B8%8E-bashrc/"/>
    <id>http://iamtutu.com/2015/04/30/git-bash-之-export-与-bashrc/</id>
    <published>2015-04-30T02:05:35.000Z</published>
    <updated>2015-04-30T02:23:40.000Z</updated>
    <content type="html"><![CDATA[<p>在 git bash 里面，用 export 命令可以显示出当前命令行工具的变量。常见的如 <code>PATH</code> 或 <code>PWD</code> 等。</p>
<h3 id="1-_环境变量_in_Windows">1. 环境变量 in Windows</h3><ul>
<li>在环境变量里面增加变量，需要重启电脑才会在生效之后，才能 <code>export</code> 的时候读到新变量。</li>
</ul>
<h3 id="2-_~/-bashrc_文件">2. ~/.bashrc 文件</h3><ul>
<li>~/.bashrc 文件会在每次打开 git bash 时候被执行</li>
<li>在 ~/.bashrc 文件中写入函数，可以在 git bash 中用函数名执行函数中的命令</li>
<li>~/.bashrc 文件中用 <code>export http_proxy=http://proxy.XXX.com:8080</code> 的形式，可以向命令行添加变量，在每次打开 git bash 后会执行。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[git bash 之 export 与 ~/.bashrc]]>
    
    </summary>
    
      <category term="git" scheme="http://iamtutu.com/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JS 怎么克隆对象？]]></title>
    <link href="http://iamtutu.com/2015/04/27/JS-%E6%80%8E%E4%B9%88%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1%EF%BC%9F/"/>
    <id>http://iamtutu.com/2015/04/27/JS-怎么克隆对象？/</id>
    <published>2015-04-27T09:12:03.000Z</published>
    <updated>2015-04-30T02:29:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="对象克隆">对象克隆</h2><p>不能影响到原来的对象，并且需要深层拷贝的情况，比如原始对象为：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var oldObj = &#123;<span class="string">a:</span><span class="number">2123</span>, <span class="string">b:</span><span class="number">2312</span>, <span class="string">c:</span>[<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">2</span>]&#125;;</span><br></pre></td></tr></table></figure>
<p>考虑以下方法：</p>
<p>1、使用 JSON API</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure>
<p>2、考虑 jquery extend</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> newObj = $.<span class="function"><span class="title">extend</span><span class="params">(  )</span></span></span><br></pre></td></tr></table></figure>
<p>3、 new Object() </p>
<p>balabalabala….再研究。。。</p>
<h2 id="demo">demo</h2><p><a href="http://jsbin.com/hudoke/2/edit" target="_blank" rel="external">In JS Bin</a></p>
<h2 id="速度测试">速度测试</h2><p><a href="http://jsperf.com/clone-object-ways" target="_blank" rel="external">In JS performance</a></p>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[JS 克隆对象, JSON, $.extend, 性能]]>
    
    </summary>
    
      <category term="js" scheme="http://iamtutu.com/categories/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git 不小心提交了的目录下有 .git 文件，咋办？]]></title>
    <link href="http://iamtutu.com/2015/04/22/git-%E4%B8%8D%E5%B0%8F%E5%BF%83%E6%8F%90%E4%BA%A4%E4%BA%86%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%9C%89-git-%E6%96%87%E4%BB%B6%EF%BC%8C%E5%92%8B%E5%8A%9E%EF%BC%9F/"/>
    <id>http://iamtutu.com/2015/04/22/git-不小心提交了的目录下有-git-文件，咋办？/</id>
    <published>2015-04-22T09:31:15.000Z</published>
    <updated>2015-04-22T09:45:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git_文件目录下有_-git_文件">git 文件目录下有 <code>.git</code> 文件</h2><p>不小心把子目录下一个 .git 文件给 add commit 了，于是没有办法再跟踪 这个目录下文件的变化。<br>submodules 什么的真是</p>
<p>发现强制删除次文件夹之后，然后再添加就可以了，记得再添加的时候，把文件夹里面的.git 文件删除掉先。<br>1、 强制删除</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf xxx<span class="regexp">/needtodelete/</span></span><br></pre></td></tr></table></figure>
<p>2、添加没有 .git 文件的文件夹 </p>
<p>3、重新加到主 git 库<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_ins">add</span> . &amp;&amp; git commit -m '<span class="built_ins">add</span> dir'</span><br></pre></td></tr></table></figure></p>
<p>这样又能重新管理这个文件夹的版本控制了，o(∩_∩)o 哈哈</p>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[git submodule 错误]]>
    
    </summary>
    
      <category term="git" scheme="http://iamtutu.com/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我就是记不住 callee 与 caller 的区别]]></title>
    <link href="http://iamtutu.com/2015/04/22/%E6%88%91%E5%B0%B1%E6%98%AF%E8%AE%B0%E4%B8%8D%E4%BD%8F-callee-%E4%B8%8E-caller-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://iamtutu.com/2015/04/22/我就是记不住-callee-与-caller-的区别/</id>
    <published>2015-04-22T08:53:14.000Z</published>
    <updated>2015-04-22T09:26:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="魔法阵在召唤~~~~">魔法阵在召唤~~~~</h1><h3 id="caller_与_callee">caller 与 callee</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee [kɔ:'li:] 被召者 当前函数--我</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'callee====='</span>,<span class="built_in">arguments</span>.callee)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// caller ['kɔ:lə] 召唤者 调用当前函数的函数--调用我的函数</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'caller====='</span>,<span class="built_in">arguments</span>.callee.caller)</span><br><span class="line"> <span class="comment">//or console.log(fun1.caller)	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fun1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun2();</span><br></pre></td></tr></table></figure>
<p><a href="http://jsbin.com/miqok/5/edit" target="_blank" rel="external">demo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[js 中的 callee 与 caller 的区别]]>
    
    </summary>
    
      <category term="js" scheme="http://iamtutu.com/categories/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[音乐乐理笔记]]></title>
    <link href="http://iamtutu.com/2015/02/14/0214-%E9%9F%B3%E4%B9%90%E4%B9%90%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>http://iamtutu.com/2015/02/14/0214-音乐乐理笔记/</id>
    <published>2015-02-14T09:02:21.000Z</published>
    <updated>2015-02-13T09:05:35.000Z</updated>
    <content type="html"><![CDATA[<p>@(音乐)[guitar,乐理]&gt;</p>
<h1 id="我的吉他乐理笔记">我的吉他乐理笔记</h1><p>之前，有借到同事的一本李重光写的《新编通俗基本乐理》，想要学习下乐理的调式和声这些东西，但是狼吞虎咽的看下来，许多概念有些混淆了。</p>
<p>之后，又在<a href="http://www.jitashe.net/thread/21405/" target="_blank" rel="external">吉他社</a>发现了这个帖子，找到大神写的一些给我们菜鸟科普的乐理教程，于是整理整理，写点笔记。</p>
<h2 id="音名和唱名">音名和唱名</h2><h3 id="音名（字母名）">音名（字母名）</h3><blockquote>
<p> <strong>音名</strong> = 基本音级的名称 + 变化音级的名称</p>
</blockquote>
<p><strong>音名在钢琴上和五线谱上，都是固定不变的。</strong></p>
<p><strong>基本音级：</strong><code>C D E F G A B</code></p>
<p><strong>变化音级：</strong> 升音级 + 降音级 + 重升音级 + 重降音级</p>
<ul>
<li>升音级：<code>#C #D ...</code> </li>
<li>降音级：<code>bC bD ...</code> </li>
<li>重升音级：<code>*C *D ...</code> （升高一个全音）</li>
<li>重降音级：<code>bbC bbD ...</code> （降低一个全音）</li>
</ul>
<p>PS: 变化音级的升号（#）降号（b）等写在音名的左上角。</p>
<h3 id="唱名">唱名</h3><p><code>do re mi fa sol la si</code></p>
<p><strong>唱名在钢琴键盘和谱子上的叫法，不固定，视唱名法的不同而不同。</strong></p>
<h3 id="唱名法">唱名法</h3><blockquote>
<p>唱名法就是唱谱的方法，常用的有：固定唱名法和首调唱名法。</p>
</blockquote>
<p><strong>固定唱名法</strong></p>
<p>所有的调都按C调的唱名唱，字母名和唱名是统一的。遇到升号唱高半音，遇到降号唱低半音，唱名固定。</p>
<p><strong>首调唱名法</strong></p>
<p>什么调的谱子就把什么音当做<code>Do</code>来唱。正如简谱中的 <code>1=C, 1=D, 1=bB</code> 一样。</p>
<p>采用首调唱名法学习乐理，关键是搞清楚每个调的<code>do re mi fa sol la si</code> 的字母名是什么。</p>
<p>首调唱名法的优点是：无论什么调，音程、和弦、调式音阶的唱名是一样的。也就是只要把C调的这些东西搞懂后，其他的调同理可得。</p>
<h2 id="调">调</h2><p><strong>调和调式是两个完全不同的概念。</strong></p>
<blockquote>
<p>对调的定义有个简单的解释：在首调唱名法中，do的音高的位置叫做调。（即 do = C 为C调，do = #F为#F调）</p>
</blockquote>
<h2 id="调式">调式</h2><blockquote>
<p>由特定数量的音按照特定的音程关系组成的音的排列就是调式</p>
</blockquote>
<p>由C调来举例，C调中得音构成的调式都属于C调，即C调的常用调式有：C大调、a小调、C宫调、D商调、E角调、G徵调、A羽调。</p>
<p>调式中的音的数量不是固定的，下面是一些常用的调式的音和音程关系。（-表示一个半音）</p>
<p>调式中每个音都有自己特有的名称和号数，例如：在C大调和a小调中</p>
<table>
<thead>
<tr>
<th style="text-align:center">调式</th>
<th style="text-align:center">唱名</th>
<th style="text-align:center">级别</th>
<th style="text-align:center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C大调</td>
<td style="text-align:center">do</td>
<td style="text-align:center">第 Ⅰ 级</td>
<td style="text-align:center">主音</td>
</tr>
<tr>
<td style="text-align:center">C大调</td>
<td style="text-align:center">re</td>
<td style="text-align:center">第 Ⅱ 级</td>
<td style="text-align:center">上主音</td>
</tr>
<tr>
<td style="text-align:center">C大调</td>
<td style="text-align:center">mi</td>
<td style="text-align:center">第 Ⅲ 级</td>
<td style="text-align:center">中音</td>
</tr>
<tr>
<td style="text-align:center">C大调</td>
<td style="text-align:center">fa</td>
<td style="text-align:center">第 Ⅳ 级</td>
<td style="text-align:center">下属音</td>
</tr>
<tr>
<td style="text-align:center">C大调</td>
<td style="text-align:center">sol</td>
<td style="text-align:center">第 Ⅴ 级</td>
<td style="text-align:center">属音</td>
</tr>
<tr>
<td style="text-align:center">C大调</td>
<td style="text-align:center">la</td>
<td style="text-align:center">第 Ⅵ 级</td>
<td style="text-align:center">下中音</td>
</tr>
<tr>
<td style="text-align:center">C大调</td>
<td style="text-align:center">si</td>
<td style="text-align:center">第 Ⅶ 级</td>
<td style="text-align:center">导音</td>
</tr>
</tbody>
</table>
<p><strong>a小调：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">调式</th>
<th style="text-align:center">唱名</th>
<th style="text-align:center">级别</th>
<th style="text-align:center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a小调</td>
<td style="text-align:center">la</td>
<td style="text-align:center">第 Ⅰ 级</td>
<td style="text-align:center">主音</td>
</tr>
<tr>
<td style="text-align:center">a小调</td>
<td style="text-align:center">si</td>
<td style="text-align:center">第 Ⅱ 级</td>
<td style="text-align:center">上主音</td>
</tr>
<tr>
<td style="text-align:center">a小调</td>
<td style="text-align:center">do</td>
<td style="text-align:center">第 Ⅲ 级</td>
<td style="text-align:center">中音</td>
</tr>
<tr>
<td style="text-align:center">a小调</td>
<td style="text-align:center">re</td>
<td style="text-align:center">第 Ⅳ 级</td>
<td style="text-align:center">下属音</td>
</tr>
<tr>
<td style="text-align:center">a小调</td>
<td style="text-align:center">mi</td>
<td style="text-align:center">第 Ⅴ 级</td>
<td style="text-align:center">属音</td>
</tr>
<tr>
<td style="text-align:center">a小调</td>
<td style="text-align:center">fa</td>
<td style="text-align:center">第 Ⅵ 级</td>
<td style="text-align:center">下中音</td>
</tr>
<tr>
<td style="text-align:center">a小调</td>
<td style="text-align:center">sol</td>
<td style="text-align:center">第 Ⅶ 级</td>
<td style="text-align:center">导音</td>
</tr>
</tbody>
</table>
<h3 id=""> </h3>]]></content>
    <summary type="html">
    <![CDATA[简单的音乐乐理的概念，包括音名和唱名、调和调式的介绍]]>
    
    </summary>
    
      <category term="音乐" scheme="http://iamtutu.com/categories/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[clip stadio paint 初学教程及使用方法（Ver 1.3.9）]]></title>
    <link href="http://iamtutu.com/2015/02/13/0213-clipstadiopaint%E5%88%9D%E5%AD%A6%E6%95%99%E7%A8%8B/"/>
    <id>http://iamtutu.com/2015/02/13/0213-clipstadiopaint初学教程/</id>
    <published>2015-02-13T08:58:37.000Z</published>
    <updated>2015-02-13T09:01:30.000Z</updated>
    <content type="html"><![CDATA[<p>参考教程</p>
<blockquote>
<p><a href="http://www.clip-studio.com/clip_site/howto/library/page/view/clipstudiopaint_hajimete_before_003" target="_blank" rel="external">《日本官网教程》</a><br><a href="http://www.pixvi.net/pitech/?p=279" target="_blank" rel="external">《静音双子的上色过程》</a> — p站</p>
</blockquote>
<h2 id="基本用法">基本用法</h2><p>常用快捷键</p>
<ul>
<li>P.S: 在放大缩小的时候， Mac OS X 的用法是先按 [ Space ]键，再按[ Command ]键。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left"><strong><em>**</em></strong></th>
<th style="text-align:center">Windows</th>
<th style="text-align:center">Macintosh</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">显示全部</td>
<td style="text-align:center">[Ctrl]+[0(数字))]</td>
<td style="text-align:center">[Command]+[0(数字)]</td>
</tr>
<tr>
<td style="text-align:left">扩大/缩小</td>
<td style="text-align:center">[Ctrl]+[Space]+([Alt]缩小)</td>
<td style="text-align:center">[Command]+[Space]+([Alt]缩小)</td>
</tr>
<tr>
<td style="text-align:left">画布移动</td>
<td style="text-align:center">[Space]</td>
<td style="text-align:center">[Space]</td>
</tr>
<tr>
<td style="text-align:left">画布旋转</td>
<td style="text-align:center">[Shift]+[Space]</td>
<td style="text-align:center">[Shift]+[Space]</td>
</tr>
<tr>
<td style="text-align:left">画布清空</td>
<td style="text-align:center">[Delete]</td>
<td style="text-align:center">[Delete]</td>
</tr>
</tbody>
</table>
<h2 id="插画创作基本流程">插画创作基本流程</h2><h3 id="草稿（下描き）">草稿（下描き）</h3><p><strong>[1]描线</strong></p>
<p>选择铅笔画草稿，调整合适你的笔大小和颜色</p>
<p><strong>[2]線を修正する</strong></p>
<p>选择橡皮工具，调整他的大小然后擦出多余的线条</p>
<h3 id="描线">描线</h3><p><strong>[1]新建描线层</strong></p>
<p><strong>[2]选择钢笔工具的G笔</strong><br>调整笔的大小和颜色，开画。</p>
<h3 id="上色">上色</h3><p><strong>[1]新建上色图层</strong></p>
<p>建议每个颜色一个图层，按涂得部分命名，比如：身体、头发、衣服等等。</p>
<p><strong>[2]上色工具</strong></p>
<p>可以用钢笔工具或其他如铅笔铺色，橡皮擦清除超出的部分，或者用填充工具来填充封闭的区域。</p>
<p>水彩可以涂比较温和的光色，比如脸上的红晕等</p>
<p><strong>[3]铺色</strong></p>
<p>填入每个区块的基本颜色</p>
<p><strong>[4]投影</strong></p>
<ul>
<li>假设光的强度和照过来的方向，不同时间（早中晚）、不同环境的光是不一样的</li>
<li>根据光，在合适的地方用笔轻轻地加深一下</li>
</ul>
<p><strong>[5]反光点</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[clip stadio paint 初学教程和常用快捷键]]>
    
    </summary>
    
      <category term="手绘" scheme="http://iamtutu.com/categories/%E6%89%8B%E7%BB%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AMD 与 CMD]]></title>
    <link href="http://iamtutu.com/2015/01/12/CMD%20%E5%92%8C%20AMD/"/>
    <id>http://iamtutu.com/2015/01/12/CMD 和 AMD/</id>
    <published>2015-01-12T03:06:59.000Z</published>
    <updated>2015-04-30T02:30:00.000Z</updated>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>&amp;&amp;</th>
<th>AMD</th>
<th>CMD</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>Asynchronous Module Definition</td>
<td>Common Module Definition</td>
</tr>
<tr>
<td>推广源</td>
<td>RequireJS</td>
<td>SeaJS</td>
</tr>
<tr>
<td>模块执行</td>
<td>提前执行</td>
<td>延迟执行</td>
</tr>
<tr>
<td>依赖写法</td>
<td>依赖就近</td>
<td>依赖前置</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[AMD 和 CMD 做的一些小对比]]>
    
    </summary>
    
      <category term="规范" scheme="http://iamtutu.com/categories/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015不是本命，也要拼命]]></title>
    <link href="http://iamtutu.com/2015/01/10/2015%E4%B8%8D%E6%98%AF%E6%9C%AC%E5%91%BD%EF%BC%8C%E4%B9%9F%E8%A6%81%E6%8B%BC%E5%91%BD%E2%80%94%E2%80%94%E6%9C%80%E8%BF%91%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B2015%E6%98%A5/"/>
    <id>http://iamtutu.com/2015/01/10/2015不是本命，也要拼命——最近要做的事2015春/</id>
    <published>2015-01-10T03:06:59.000Z</published>
    <updated>2015-02-13T06:29:56.000Z</updated>
    <content type="html"><![CDATA[<p>又这样过了几个月，忙着一个又一个的项目。到了年末，发现自己原来想看的东西、想学的似乎并没有怎么动 ╮(╯_╰)╭</p>
<p>再来个Todo-list吧！</p>
<h3 id="1-_拜读_jQuery_源码">1. 拜读 jQuery 源码</h3><p>每次说使用熟练的时候，又好怕被问道 <code>“你看了源码了吗?”</code>。</p>
<p>好的，我这就去看。</p>
<h3 id="2-_ES5_ES6的东西">2. ES5 ES6的东西</h3><p>前端圈的大神们都在讨论Node.js、fibjs、AngularJS、IO.js什么的，</p>
<p>哎╮(╯_╰)╭想看又看不懂，我这等菜鸟只能本分的从根本做起罗。</p>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[2015 新春要做的事情]]>
    
    </summary>
    
      <category term="to-do" scheme="http://iamtutu.com/categories/to-do/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[window.history 复习]]></title>
    <link href="http://iamtutu.com/2014/11/02/1101-history/"/>
    <id>http://iamtutu.com/2014/11/02/1101-history/</id>
    <published>2014-11-02T03:06:59.000Z</published>
    <updated>2015-04-30T02:27:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="复习">复习</h2><p>模拟用户点击浏览器后退按钮<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.<span class="keyword">back</span>();</span><br></pre></td></tr></table></figure></p>
<p>模拟用户点击浏览器前进按钮<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.forward();</span><br></pre></td></tr></table></figure></p>
<p>可以用go()方法加载在session历史记录中的某个页面，参数是一个相对于当前页面的index值（当前页面是index0）</p>
<p>后退一页<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.<span class="keyword">history</span>.<span class="keyword">go</span>(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>前进一页<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.<span class="keyword">history</span>.<span class="keyword">go</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>history栈的页面数量可以由length属性得到：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> numberOfEntries = <span class="built_in">window</span>.history.length;</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong>  Internet Explorer 支持将URL字符串作为参数传给go()，这种用法不是标准的用法，且Gecko不支持。</p>
<h2 id="HTML5_History">HTML5 History</h2><p>HTML5 引入了<code>history.pushState( )</code> 和 <code>history.replaceState( )</code> 方法，他们分别允许你添加和修改history实体。他们可以结合<code>window.onpopstate</code> 事件使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[使用 window.history 来控制浏览器前进和后退]]>
    
    </summary>
    
      <category term="js" scheme="http://iamtutu.com/categories/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[getBoundClientRect 函数详解]]></title>
    <link href="http://iamtutu.com/2014/10/26/1013-getBoundClientRect/"/>
    <id>http://iamtutu.com/2014/10/26/1013-getBoundClientRect/</id>
    <published>2014-10-26T03:06:59.000Z</published>
    <updated>2015-02-13T06:40:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="getBoundClientRect函数详解">getBoundClientRect函数详解</h2><p><a href="http://www.cnblogs.com/2050/archive/2012/02/01/2335211.html" target="_blank" rel="external">转载自这里</a></p>
<h3 id="一、定义">一、定义</h3><p>getBoundingClientRect 函数是W3C组织在第一版本的W3C CSSOM View specification草案中确定的一个标准方法，在此之前，只有IE浏览器是支持该方法的，W3C在这次草案中把它扶正成为标准，足可以看出它并不简单。getBoundingClientRect 方法返回的是调用该方法的元素的TextRectangle对象，该对象具有top、left、right、bottom四个属性，分别代表该元素上、左、右、下四条边界相对于浏览器窗口左上角（注意，不是文档区域的左上角）的偏移像素值。</p>
<h3 id="二、兼容性">二、兼容性</h3><p>getBoundingClientRect方法最先在IE5中出现，后来被W3C接纳成为标准。目前IE5.5+、Firefox 3.5+、Chrome 4+、Safari 4.0+、Opara 10.10+等浏览器均支持该方法，兼容性几乎完美。</p>
<p>在具体表现方面，Firefox6以前的版本使用getBoundingClientRect时不能获取到top和bottom这两个属性值，Firefox6及以后的版本和其他支持getBoundingClientRect方法的浏览器则top、left、right、bottom四个属性值均能获取到。需要说明的是由于某些版本的IE浏览器的<html>文档根元素默认是有2px边框的,所以这里需要特别处理一下，微软MSDN上说在IE5中会存在这样的情况，但据我实际测试，xp系统中IE6也存在这样的问题，奇怪的是，我在win7环境下用IETester测试的IE各版本都是正常的。但这并不是什么大问题，我们只要把得到的值减去html根元素（body也可考虑进来）的clientLeft或clientTop就能保持各浏览器一致啦。</html></p>
<h3 id="三、用途">三、用途</h3><p>当getBoundingClientRect刚被w3c列为标准的时候，PPK还曾质疑过它是不是多此一举，因为已经存在类似的方法来获取元素的偏移位置，比如offsetLeft和offsetTop。但Jquery的作者John Resig马上阐明了getBoundingClientRect的用处。用传统的方法固然可以实现getBoundingClientRect同样的功能，但兼容各种浏览器以及各种不同的元素就会把你弄死，而且效率还非常低下。所以获取页面上某个元素相对于浏览器窗口的偏移量就成了getBoundingClientRect的用武之地了。而获取元素的偏移量能有什么用，我相信，你懂的~ ^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[getBoundClientRect 函数介绍]]>
    
    </summary>
    
      <category term="js" scheme="http://iamtutu.com/categories/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Protractor 学习笔记]]></title>
    <link href="http://iamtutu.com/2014/09/30/0930-protractor/"/>
    <id>http://iamtutu.com/2014/09/30/0930-protractor/</id>
    <published>2014-09-30T03:06:59.000Z</published>
    <updated>2015-04-30T02:32:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="准备活动">准备活动</h2><h3 id="简介">简介</h3><p>protractor 是个 <a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> 程序。所以首先得安装 Node.js。然后就可以使用npm 安装 protractor 了。</p>
<p>通常 protractor 使用 <a href="http://jasmine.github.io/1.3/introduction.html" target="_blank" rel="external">Jasmine</a> 测试框架作为他的测试接口。</p>
<p>下面的教程的测试将使用一个独立的 Selenium Server 来控制浏览器。需要安装 JDK 来运行这个服务器。可以用 <code>java -version</code> 命令来测试是否安装成功 JDK。</p>
<h3 id="安装">安装</h3><p>全局安装protractor<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g protractor</span><br></pre></td></tr></table></figure></p>
<p>这个命令会安装两个命令行工具，protractor 和 webdriver-manager。尝试跑 <code>protractor --version</code> 确认安装成功。webdriver-manager 是一个辅助工具，他可以简单的让Selenium Server 的实例跑起来？？用这个命令可以让他来下载必要的 binaries：<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webdriver-manager <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p>
<p>现在可以打开一个服务器<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webdriver-manager <span class="built_in">start</span></span><br></pre></td></tr></table></figure></p>
<p>这个命令会开启一个Selenium Server ，然后输出一串的 log 信息。你的 Protractor 测试将会把请求发到服务器来控制本地的浏览器。在整个教程中，请让服务器在后面撒欢的跑。你可以到这里看服务器的状态信息 <a href="http://localhost:4444/wd/hub" target="_blank" rel="external">http://localhost:4444/wd/hub</a> 。</p>
<h2 id="step_0_-_写一测试">step 0 - 写一测试</h2><p>新开个命令行或终端窗口，并选个干净整洁的文件夹来做测试目录。</p>
<p>Protractor 运行需要两个文件，一个是 <strong>spec file</strong> ，一个是 <strong>configuration file</strong>。</p>
<p>我们先从一个简单的测试开始，内容是引导一个Angular app 例子和检验他的title。我们将会用到这里的 Super Calculator application —— <a href="http://juliemr.github.io/protractor-demo/" target="_blank" rel="external">http://juliemr.github.io/protractor-demo/</a></p>
<p>将下面的代码 copy 到 spec.js 中：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spec.js</span></span><br><span class="line">describe(<span class="string">'angularjs homepage'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  it(<span class="string">'should have a title'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    browser.<span class="keyword">get</span>(<span class="string">'http://juliemr.github.io/protractor-demo/'</span>);</span><br><span class="line"></span><br><span class="line">    expect(browser.getTitle()).toEqual(<span class="string">'Super Calculator'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p> 这里 <code>describe</code> 和 <code>it</code> 语法来自 Jasmine 框架。<code>browser</code> 由 Protractor 全局创建的，他可以用来执行浏览器级别的命令，例如用 <code>browser</code> 导航。</p>
<p>现在来创建配置文件，将下面的代码 copy 到 conf.js：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// conf.js</span></span><br><span class="line">exports.config = &#123;</span><br><span class="line">  seleniumAddress: 'http:<span class="comment">//localhost:4444/wd/hub',</span></span><br><span class="line">  specs: ['spec.js']</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个配置文件通知 Protractor 你的测试文件（specs）的位置，还有Selenium Server 的对话地址（seleniumAddress）。其他配置项使用默认的，Chrome是默认浏览器。</p>
<p>现在运行测试<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">protractor</span> conf.js</span><br></pre></td></tr></table></figure></p>
<p>OK! 我们会看到 Chrome 打开一个指向 Calculator 的窗口，然后又闪关了。测试结果输出应为 <code>1 tests, 1 assertion, 0 failures</code>。真是可喜可贺，我们第一个 Protractor 测试已经成功了 (^o^)/~</p>
<h2 id="step_1_-_元素交互">step 1 - 元素交互</h2><p>现在来修改下测试文件，让他与页面上的文件进行交互吧！变 ~ 身 ~<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spec.js</span></span><br><span class="line">describe(<span class="string">'angularjs homepage'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  it(<span class="string">'should add one and two'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    browser.<span class="keyword">get</span>(<span class="string">'http://juliemr.github.io/protractor-demo/'</span>);</span><br><span class="line">    element(by.model(<span class="string">'first'</span>)).sendKeys(<span class="number">1</span>);</span><br><span class="line">    element(by.model(<span class="string">'second'</span>)).sendKeys(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    element(by.id(<span class="string">'gobutton'</span>)).click();</span><br><span class="line"></span><br><span class="line">    expect(element(by.binding(<span class="string">'latest'</span>)).getText()).</span><br><span class="line">        toEqual(<span class="string">'5'</span>); <span class="comment">// This is wrong!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里也使用了两个 Protractor 创建的全局 <code>elemenet</code> 和 <code>by</code>。<code>element</code> 函数用来寻找页面 HTML 元素，他会返回一个 ElementFinder 对象，这个对象可与元素交互或者获取他们的信息（狗仔队~~）。在这个测试中，我们使用 <code>sendKeys</code> 来给 <code>&lt;input&gt;</code> 输入值，<code>click</code> 来点击按钮，<code>getText</code> 来返回元素的内容。</p>
<p><code>element</code> 需要一个定位仪参数。<code>by</code> 元素创建了定位仪，我们使用三个类型的定位仪。</p>
<ul>
<li><code>by.model(&#39;first&#39;)</code> 来查找元素 <code>ng-model=&quot;first&quot;</code>。</li>
<li><code>by.id(&#39;gobutton&#39;)</code> 来根据给定的id查找。</li>
<li><code>by.binding(&#39;latest&#39;)</code> 来发现绑定了latest变量的元素，即 <code>{ {latest} }</code></li>
</ul>
<p><a href="http://angular.github.io/protractor/#/locators" target="_blank" rel="external">关于定位仪 (by) 和元素查找器 (element) 的更多信息</a></p>
<p>运行测试<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">protractor</span> conf.js</span><br></pre></td></tr></table></figure></p>
<p>1 + 2 == 5肯定会 failed 啦~(≧▽≦)/~啦啦啦 </p>
<h2 id="step_2_-_多个测试">step 2 - 多个测试</h2><p>稍微美化点，将两个测试结合起来，提出重复的部分</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spec.js</span></span><br><span class="line">describe(<span class="string">'angularjs homepage'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstNumber = element(by.model(<span class="string">'first'</span>));</span><br><span class="line">  <span class="keyword">var</span> secondNumber = element(by.model(<span class="string">'second'</span>));</span><br><span class="line">  <span class="keyword">var</span> goButton = element(by.id(<span class="string">'gobutton'</span>));</span><br><span class="line">  <span class="keyword">var</span> latestResult = element(by.binding(<span class="string">'latest'</span>));</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    browser.<span class="keyword">get</span>(<span class="string">'http://juliemr.github.io/protractor-demo/'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should have a title'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expect(browser.getTitle()).toEqual(<span class="string">'Super Calculator'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should add one and two'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    firstNumber.sendKeys(<span class="number">1</span>);</span><br><span class="line">    secondNumber.sendKeys(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    goButton.click();</span><br><span class="line"></span><br><span class="line">    expect(latestResult.getText()).toEqual(<span class="string">'3'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should add four and six'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fill this in.</span></span><br><span class="line">    expect(latestResult.getText()).toEqual(<span class="string">'10'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里，我们将导航拉到一个 <code>beforeEach</code> 函数里，他会运行在每个 <code>it</code> 块前。</p>
<h2 id="step_3_-_改变配置">step 3 - 改变配置</h2><p>变 ~ 身 ~ (^o^)/~<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// conf.js</span></span><br><span class="line">exports.config = &#123;</span><br><span class="line">  seleniumAddress: 'http:<span class="comment">//localhost:4444/wd/hub',</span></span><br><span class="line">  specs: ['spec.js'],</span><br><span class="line">  capabilities: &#123;</span><br><span class="line">    browserName: 'firefox'</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尝试重新运行测试。我们可以看到 Firefox 代替 chrome 跑了出来。<code>capabilities</code> 对象描述了测试使用的浏览器。所有可用的选项，看这里 <a href="https://github.com/angular/protractor/blob/master/docs/referenceConf.js" target="_blank" rel="external">the reference config file</a></p>
<p>还可以一次在多个浏览器中跑测试，像这样<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// <span class="atom">conf</span>.<span class="atom">js</span></span><br><span class="line"><span class="atom">exports</span>.<span class="atom">config</span> = &#123;</span><br><span class="line">  <span class="atom">seleniumAddress</span>: <span class="string">'http://localhost:4444/wd/hub'</span>,</span><br><span class="line">  <span class="atom">specs</span>: [<span class="string">'spec.js'</span>],</span><br><span class="line">  <span class="atom">multiCapabilities</span>: [&#123;</span><br><span class="line">    <span class="atom">browserName</span>: <span class="string">'firefox'</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="atom">browserName</span>: <span class="string">'chrome'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家可以试试看效果。Chrome 和 Firefox 会同步进行测试，命令行中的结果是独立显示的。</p>
<p>我的 Firefox 没有安装在默认 C 盘的路径上，所以有报错 <code>Cannot find firefox binary in PATH. Make sure firefox is installed.</code> ，把 <code>firefox.exe</code> 的路径加在了系统变量 PATH ，也没有解决。</p>
<p>这个问题修改的<a href="http://sariyalee.iteye.com/blog/1688271" target="_blank" rel="external">参考文章</a>，万万没想到，我最后还是重装了Firefox。不知道以后还能不能愉快地自定义安装地址了呢╮(╯▽╰)╭</p>
<h2 id="step_4_-_元素列表">step 4 - 元素列表</h2><p>重新回到测试文件，有时会遇到多个元素的列表需要处理的问题。可以用 <code>element.all</code> 处理，这个方法会返回一个 ElementArrayFinder。在我们的这个 Calculator app 中，每个操作都记录在一个历史的表格中，使用的是 Angular 的 <code>ng-repeater</code>。下面让我们来测试这些操作是否记录在表格中。</p>
<p>变 ~ 身 ~ (^o^)/~<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spec.js</span></span><br><span class="line">describe(<span class="string">'angularjs homepage'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> firstNumber = element(by.model(<span class="string">'first'</span>));</span><br><span class="line">  <span class="keyword">var</span> secondNumber = element(by.model(<span class="string">'second'</span>));</span><br><span class="line">  <span class="keyword">var</span> goButton = element(by.id(<span class="string">'gobutton'</span>));</span><br><span class="line">  <span class="keyword">var</span> latestResult = element(by.binding(<span class="string">'latest'</span>));</span><br><span class="line">  <span class="keyword">var</span> history = element.all(by.repeater(<span class="string">'result in memory'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    firstNumber.sendKeys(a);</span><br><span class="line">    secondNumber.sendKeys(b);</span><br><span class="line">    goButton.click();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    browser.<span class="keyword">get</span>(<span class="string">'http://juliemr.github.io/protractor-demo/'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should have a history'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    expect(history.count()).toEqual(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    add(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    expect(history.count()).toEqual(<span class="number">0</span>); <span class="comment">// This is wrong!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里我们做了两件事：</p>
<ul>
<li>首先，我们创建了一个辅助函数<code>add</code>，并且增加了变量 <code>history</code>。</li>
<li>我们用了 <code>element.all</code> 结合 <code>by.repeater</code> 定位仪来获得一个 ElementArrayFinder。在 spec 文件中，我们用了count函数计算了历史记录的应有 length 。</li>
</ul>
<p><code>ElementArrayFinder</code> 处理 <code>add</code> 外还有许多方法。用 <code>last</code> 来获得一个匹配定位仪获得元素集中的最后一个元素。</p>
<pre><code>it<span class="list">(<span class="quoted">'should</span> have a history', function<span class="list">()</span> {
    add<span class="list">(<span class="number">1</span>, <span class="number">2</span>)</span><span class="comment">;</span>
    add<span class="list">(<span class="number">3</span>, <span class="number">4</span>)</span><span class="comment">;</span>

    expect<span class="list">(<span class="keyword">history</span>.last<span class="list">()</span>.getText<span class="list">()</span>)</span>.toContain<span class="list">('<span class="number">1</span> + <span class="number">2</span>')</span><span class="comment">;</span>
    expect<span class="list">(<span class="keyword">history</span>.first<span class="list">()</span>.getText<span class="list">()</span>)</span>.toContain<span class="list">(<span class="quoted">'foo</span>')</span><span class="comment">; // This is wrong!</span>
  })</span><span class="comment">;</span>
</code></pre><p>因为 Calculator 展示了最老的结果在底部，我们用 <code>toContain</code> Jasmine 匹配来假设元素的文字包含有“1+2”。</p>
<p>ElementArrayFinder 还有 <code>each</code>、<code>map</code>、 <code>filter</code> 和 <code>reduce</code> 这些方法和 JS 的数组方法很相似。<a href="http://angular.github.io/protractor/#/api?view=ElementArrayFinder" target="_blank" rel="external">更多 API 细节看这里</a></p>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[安装 protractor 和他的基本用法]]>
    
    </summary>
    
      <category term="test" scheme="http://iamtutu.com/categories/test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angular Bootstrapping 引导]]></title>
    <link href="http://iamtutu.com/2014/09/26/0926-angular%20lesson2/"/>
    <id>http://iamtutu.com/2014/09/26/0926-angular lesson2/</id>
    <published>2014-09-26T03:06:59.000Z</published>
    <updated>2015-02-13T06:11:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="angular_Bootstrapping——_引导">angular Bootstrapping—— 引导</h2><h2 id="step_0">step 0</h2><p>进入 <code>angular-phonecat</code> 的目录，运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="operator">-f</span> step-<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个命令会重置我们的工作区到教程的初始步骤step 0。<br>跑 <code>npm start</code> ，进可以通过 <a href="http://localhost:8000/app/" target="_blank" rel="external">http://localhost:8000/app/</a> 浏览app页面。</p>
<h2 id="这些code是要闹哪样呢？">这些code是要闹哪样呢？</h2><p><code>app/index.html</code> 的code</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span> <span class="attribute">ng-app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">title</span>&gt;</span>My HTML File<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"bower_components/bootstrap/dist/css/bootstrap.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"css/app.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"bower_components/angular/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Nothing here &#123; &#123;'yet' + '!'&#125; &#125;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="ng-app"><code>ng-app</code></h3><p><code>ng-app</code> 代表Angular指令 <code>ngApp</code>,  用来标记我们的HTML元素，会让Angular 认定为 app 的 root element。大家可以自由的决定app的入口元素在哪里，html或其他元素。</p>
<h2 id="{_{_}_}"><code>{ { } }</code></h2><p>数据绑定的code</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nothing <span class="keyword">here</span> &#123; &#123;<span class="string">'yet'</span> + <span class="string">'!'</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>这行代码展示了两个Angular模板的核心特点：</p>
<ul>
<li>绑定使用双括号—— <code>{ { } }</code></li>
<li>在绑定中使用简单的表达式—— <code>&#39;yet&#39; + &#39;!&#39;</code></li>
</ul>
<p>这个绑定告诉了Angular去计算表单式，然后把结果插入DOM里绑定数据的地方。在下一步我们会看到，与单向绑定不同的是，当表达式计算的结果改变时，数据会保持更新到DOM上。</p>
<p><a href="https://docs.angularjs.org/guide/expression" target="_blank" rel="external"> Angular expression </a> 是类JS的代码缩写，他的 context 上下文是当前的module scope，而不是全局域 <code>(window)</code> 。</p>
<h2 id="Bootstrapping_AngularJS_apps">Bootstrapping AngularJS apps</h2><p>使用 <code>ngApp</code> 指令引导Angular app 很方便也适用于大部分的应用。 但是，在一些其他的使用了scripts loader的栗子中，可以使用这个来引导app——<a href="https://docs.angularjs.org/guide/bootstrap" target="_blank" rel="external"> imperative / manual</a>。</p>
<p>当APP引导的时候完成了三个重要的事情：</p>
<ol>
<li>注册器注册依赖？？</li>
<li>注册器建立根作用域，他将作为我们应用的上下文context</li>
<li>Angular从 <code>ngApp</code> 根元素开始编译DOM，处理根下面的指令和绑定们</li>
</ol>
<p>一旦一个app被引导完成，他会等待浏览器事件的触发（例如鼠标点击，键盘事件，或者HTTP应答）。一旦事件被触发，Angular就去侦测是否他会改变任何Model，然后通过更新所有相关的绑定，将改变的地方映射到View去。</p>
<p>示意图：<br><img src="http://iamtutu.qiniudn.com/tutorial_00.png" alt="angular ng-app"></p>
]]></content>
    <summary type="html">
    <![CDATA[Angular phonecat 教程 part 2 —— bootstrapping]]>
    
    </summary>
    
      <category term="Angular" scheme="http://iamtutu.com/categories/Angular/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angular Template 模板]]></title>
    <link href="http://iamtutu.com/2014/09/26/0926-angular%20lesson3/"/>
    <id>http://iamtutu.com/2014/09/26/0926-angular lesson3/</id>
    <published>2014-09-26T03:06:59.000Z</published>
    <updated>2015-02-13T06:23:24.000Z</updated>
    <content type="html"><![CDATA[<p>为了说明Angular怎样加强标准HTML，这一节会将一个纯html转为模板，Angular用他来展示一些数据集合。我们加的数据是两个手机的基本信息。</p>
<h2 id="step_1">step 1</h2><p>调整工作区到step1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="operator">-f</span> step-<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>然后别忘了 <code>npm start</code> ，在浏览器上查看新的页面展示。</p>
<p>这是个纯html的静态模板，下面看看Angular的动态模板是怎么弄的。马上就到了step 2。</p>
<h2 id="step_2">step 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="operator">-f</span> step-<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Angular比较提倡使用 <strong>MVC 设计模式</strong> 来结耦代码。由于这个理念，这个步骤使用了一些 JS 代码来增加app中的 model，view 和 controller 组件。</p>
<h3 id="View_and_Template">View and Template</h3><p>在 Angular 中，视图是模型通过 HTML 模板的映射。这意味着，无论何时数据模型的变化，都能刷新绑定点而更新视图。</p>
<p><code>app/index.html:</code></p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">ng-app</span>=<span class="value">"phonecatApp"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"bower_components/angular/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"js/controllers.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-controller</span>=<span class="value">"PhoneListCtrl"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"phone in phones"</span>&gt;</span></span><br><span class="line">      </span><span class="expression">&#123;&#123;<span class="variable">phone.name</span>&#125;&#125;</span><span class="xml"></span><br><span class="line">      <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">phone.snippet</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="ng-repeat">ng-repeat</h3><p>我们将硬代码写的phone  list 替换为 <code>ngRepeat directive</code> 和两个 Angular expression。</p>
<ul>
<li>这个 <code>ng-repeat=&quot;phone in phones&quot;</code> 属性是一个Angular repeater指令。repeater让 Angular 为每个list里的phone建立 <code>&lt;li&gt;</code> 模板。总之就是模板中的 <code>for in</code> 循环。</li>
</ul>
<h3 id="ng-controller">ng-controller</h3><p>这个指令绑定个 <code>PhoneListCtrl</code> 的 controller 到 body 上。数据 <code></code> 和 <code></code> 是他设置的，(⊙_⊙)。</p>
<h3 id="ng-app">ng-app</h3><p>前面出现的这个指令，现在给他赋值了之后，则表示 <code>phonecarApp</code> 是一个module模块名。这个模块包含着<code>PhoneListCtrl</code> 这个控制器。</p>
<p>他们的关系图：</p>
<p><img src="http://iamtutu.qiniudn.com/tutorial_02.png" alt="关系图"></p>
<h3 id="Module_and_Controller">Module and Controller</h3><p><code>app/js/controllers.js:</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phonecatApp = angular.module(<span class="string">'phonecatApp'</span>, []);</span><br><span class="line"></span><br><span class="line">phonecatApp.controller(<span class="string">'PhoneListCtrl'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">  <span class="variable">$scope</span>.phones = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'Nexus S'</span>,</span><br><span class="line">     <span class="string">'snippet'</span>: <span class="string">'Fast just got faster with Nexus S.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'Motorola XOOM™ with Wi-Fi'</span>,</span><br><span class="line">     <span class="string">'snippet'</span>: <span class="string">'The Next, Next Generation tablet.'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'MOTOROLA XOOM™'</span>,</span><br><span class="line">     <span class="string">'snippet'</span>: <span class="string">'The Next, Next Generation tablet.'</span>&#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>在html标签上定义的模块名字 <code>phonecatApp</code> ，在这里注册为 Angular 的 module。</li>
<li>然后在这个module下注册了一个控制器——<code>PhoneListCtrl</code></li>
</ol>
<p>控制器让我们能够在 model 和 view 之间建立数据绑定。<code>PhoneListCtrl</code> 控制器绑定 phone data 到 <code>$scope</code> 。这个 scope 是 root scope 的 prototypical descendant（原型子孙）？？root scope在app 开始时被定义。这个控制器的scope可以使用到任何在控制器标签中的绑定。</p>
<h3 id="scope">scope</h3><p>在Angular中scope的概念十分的重要，他是将template、model和controller公共工作的粘合剂。<br>详细的Angular scope 介绍请翻墙看：<a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope" target="_blank" rel="external"> angular scope documentation.</a> ^_^</p>
<h3 id="测试">测试</h3><h4 id="全局控制器">全局控制器</h4><p>用Angular 的方法将控制器从视图中分离，我们可以方便的编写测试代码。如果控制器在全局作用域可用，我们可用一个虚拟的scope来实例化控制器：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe<span class="list">(<span class="quoted">'PhoneListCtrl</span>', function<span class="list">()</span>&#123;</span><br><span class="line"></span><br><span class="line">it<span class="list">(<span class="quoted">'should</span> create <span class="string">"phones"</span> model with <span class="number">3</span> phones', function<span class="list">()</span> &#123;</span><br><span class="line">  var scope = &#123;&#125;,</span><br><span class="line">      ctrl = new PhoneListCtrl<span class="list">(<span class="keyword">scope</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  expect<span class="list">(<span class="keyword">scope</span>.phones.length)</span>.toBe<span class="list">(<span class="number">3</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在Angular中写单元测试挺方便啊O(∩_∩)O哈哈~<br>因为在软件开发中，测试是一个关键的步骤，所以Angular简化了测试，以鼓励coder们多写测试啊。</p>
<h4 id="非全局控制器">非全局控制器</h4><p>Angular提供了一个service服务——<code>$controller</code> 。他可以通过名字获取你的控制器。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">describe<span class="list">(<span class="quoted">'PhoneListCtrl</span>', function<span class="list">()</span>&#123;</span><br><span class="line"></span><br><span class="line">beforeEach<span class="list">(<span class="keyword">module</span><span class="list">(<span class="quoted">'phonecatApp</span>')</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it<span class="list">(<span class="quoted">'should</span> create <span class="string">"phones"</span> model with <span class="number">3</span> phones', inject<span class="list">(<span class="keyword">function</span><span class="list">($controller)</span> &#123;</span><br><span class="line">  var scope = &#123;&#125;,</span><br><span class="line">      ctrl = $controller<span class="list">(<span class="quoted">'PhoneListCtrl</span>', &#123;$scope<span class="keyword">:scope</span>&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  expect<span class="list">(<span class="keyword">scope</span>.phones.length)</span>.toBe<span class="list">(<span class="number">3</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>告诉Angular 在每个测试之前加载 <code>phonecatApp</code> 模块</li>
<li>让Angular 注册 <code>$controller</code> 服务到我们的测试函数</li>
<li>用 <code>$controller</code> 来建立一个 <code>PhoneListCtrl</code> 的实例</li>
<li>在实例中，我们来证实phones数组拥有三个记录的属性</li>
</ul>
<h3 id="Writing_and_Running_Tests_写跑测试">Writing and Running Tests 写跑测试</h3><p>angular-seed项目预先配置了使用 <strong>Karma</strong> 来跑单元测试，确保开跑前已经使用 <code>npm install</code> 安装了Karma相关的组件。</p>
<p>使用 <code>npm test</code> 开跑：</p>
<ul>
<li>Karma 会打开一个浏览器的页面来跑你的测试，可以无视</li>
<li><p>你会看到命令台输出（大概）：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info: Karma server started <span class="keyword">at</span> <span class="keyword">http</span>://localhost:<span class="number">9876</span>/</span><br><span class="line"> info (launcher): Starting  browser <span class="string">"Chrome"</span></span><br><span class="line"> info (Chrome <span class="number">22.0</span>): Connected <span class="command"><span class="keyword">on</span> <span class="title">socket</span> <span class="title">id</span> <span class="variable">tPUm9DXcLHtZTKbAEO-n</span></span></span><br><span class="line"> Chrome <span class="number">22.0</span>: Executed <span class="number">1</span> <span class="operator">of</span> <span class="number">1</span> SUCCESS (<span class="number">0.093</span> <span class="built_in">secs</span> / <span class="number">0.004</span> <span class="built_in">secs</span>)</span><br></pre></td></tr></table></figure>
<p>(^o^)/ success！！</p>
</li>
<li><p>当你修改你的test.js的源文件时，Karma会默认帮你重跑一遍，so sweet O(∩_∩)O</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Angular phonecat 教程 part 3 —— 模版]]>
    
    </summary>
    
      <category term="Angular" scheme="http://iamtutu.com/categories/Angular/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angular 模版学习2]]></title>
    <link href="http://iamtutu.com/2014/09/26/0926-angular%20lesson3%20-%20part2/"/>
    <id>http://iamtutu.com/2014/09/26/0926-angular lesson3 - part2/</id>
    <published>2014-09-26T03:06:59.000Z</published>
    <updated>2015-02-13T06:22:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Filtering_Repeaters">Filtering Repeaters</h1><h2 id="step_3">step 3</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -f step-3</span><br><span class="line"><span class="bullet">...</span><br><span class="line"></span>npm start</span><br></pre></td></tr></table></figure>
<h3 id="controller">controller</h3><p>没啥改变</p>
<h3 id="template">template</h3><p><code>app/index.html</code> </p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container-fluid"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-md-2"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Sidebar content--&gt;</span></span><br><span class="line"></span><br><span class="line">      Search: <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"query"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-md-10"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Body content--&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"phones"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"phone in phones | filter:query"</span>&gt;</span></span><br><span class="line">          </span><span class="expression">&#123;&#123;<span class="variable">phone.name</span>&#125;&#125;</span><span class="xml"></span><br><span class="line">          <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">phone.snippet</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用<code>&lt;input&gt;</code> 标签和Angular 的filter函数来处理ngRepeat指令的输入。用户可以实时看到搜索的结果：</p>
<ul>
<li>数据绑定：当页面load时，Angular绑定input的名字到一个在数据模型里的同名变量，然后保持两个同步。</li>
<li>使用filter：filter函数使用<code>query</code> 的值来创建一个新的数组，数组为匹配query的结果。即输入input的是一个过滤用的关键词，什么我输入了一个正则？？</li>
</ul>
<p>ngRepeater 自动更新视图以回应由 filter 返回的phones数组的变化</p>
<h2 id="测试">测试</h2><p>单元测试完美适合于控制器和其他组件的测试，但是没法测试DOM 操作或其他app操作。为此，使用一个end-to-end端对端的测试是更好的choice。</p>
<p>下面是个end-to-end test来验证我们的搜索功能，<code>test/e2e/scenarios.js:</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">describe<span class="list">(<span class="quoted">'PhoneCat</span> App', function<span class="list">()</span> &#123;</span><br><span class="line"></span><br><span class="line">describe<span class="list">(<span class="quoted">'Phone</span> list view', function<span class="list">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  beforeEach<span class="list">(<span class="keyword">function</span><span class="list">()</span> &#123;</span><br><span class="line">    browser.get<span class="list">(<span class="quoted">'app/index</span>.html')</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  it<span class="list">(<span class="quoted">'should</span> filter the phone list as a user types into the search box', function<span class="list">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    var phoneList = element.all<span class="list">(<span class="keyword">by</span>.repeater<span class="list">(<span class="quoted">'phone</span> in phones')</span>)</span><span class="comment">;</span></span><br><span class="line">    var query = element<span class="list">(<span class="keyword">by</span>.model<span class="list">(<span class="quoted">'query</span>')</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    expect<span class="list">(<span class="keyword">phoneList</span>.count<span class="list">()</span>)</span>.toBe<span class="list">(<span class="number">3</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    query.sendKeys<span class="list">(<span class="quoted">'nexus</span>')</span><span class="comment">;</span></span><br><span class="line">    expect<span class="list">(<span class="keyword">phoneList</span>.count<span class="list">()</span>)</span>.toBe<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    query.clear<span class="list">()</span><span class="comment">;</span></span><br><span class="line">    query.sendKeys<span class="list">(<span class="quoted">'motorola</span>')</span><span class="comment">;</span></span><br><span class="line">    expect<span class="list">(<span class="keyword">phoneList</span>.count<span class="list">()</span>)</span>.toBe<span class="list">(<span class="number">2</span>)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个end-to-end使用的是 Protractor 的 API。更多语法相关<a href="https://github.com/angular/protractor/blob/master/docs/api.md" target="_blank" rel="external">点这里 </a>.</p>
<p>使用 <code>npm run protractor</code> 命令开始测试。需要能翻墙到google，ou no !!! T^T !!!</p>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[Angular phonecat 教程 part 3 —— 模版（2）]]>
    
    </summary>
    
      <category term="Angular" scheme="http://iamtutu.com/categories/Angular/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angular Lesson 1]]></title>
    <link href="http://iamtutu.com/2014/09/25/0925-angular%20phonecat/"/>
    <id>http://iamtutu.com/2014/09/25/0925-angular phonecat/</id>
    <published>2014-09-25T03:06:59.000Z</published>
    <updated>2015-02-13T06:22:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="angular_lesson_1">angular lesson 1</h2><p>据说是官方的lesson教程，angular-phonecat</p>
<h3 id="环境安装">环境安装</h3><p>首先你得安装有下面两个东西，就像烤面包先得有烤箱。</p>
<pre><code><span class="bullet">1. </span>git
<span class="bullet">2. </span>node
</code></pre><p>然后打开git bush，进入你的工程目录，输入<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="string">https:</span><span class="comment">//github.com/angular/angular-phonecat.git</span></span><br></pre></td></tr></table></figure></p>
<p>讲这个项目从github弄下面后，<code>cd angular-phonecat</code> 进入这个目录，npm安装依赖包 <code>node install</code>。node_modules目录下面会安装以下工具：</p>
<ul>
<li>Bower - client-side code package manager</li>
<li>Http-Server - simple local static web server</li>
<li>Karma - unit test runner</li>
<li>Protractor - end to end (E2E) test runner</li>
</ul>
<p>这里有些启动他们的命令：</p>
<ul>
<li><code>npm start</code>  : start a local development web-server</li>
<li><code>npm test</code> : start the Karma unit test runner</li>
<li><code>npm run protractor</code>  : run the Protractor end to end (E2E) tests</li>
<li><code>npm run update-webdriver</code>  : install the drivers needed by Protractor</li>
</ul>
<p>如果前面的步骤都顺利的完成了，现在就可以通过 <code>npm start</code> 启动node的 http server 了。<br>打开浏览器，进入<a href="http://localhost:8000/app/index.html，看到一句Nothing" target="_blank" rel="external">http://localhost:8000/app/index.html，看到一句Nothing</a> here yet!  说明成功了。</p>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[Angular phonecat 教程 part 1 —— 介绍]]>
    
    </summary>
    
      <category term="Angular" scheme="http://iamtutu.com/categories/Angular/"/>
    
  </entry>
  
</feed>